[
  {
    "path": "posts/2021-05-28-introduction-to-functional-programming/",
    "title": "1. Introduction to Functional Programming",
    "description": "A brief introduction to Functional Programming.",
    "author": [
      {
        "name": "Shijing Zhou",
        "url": {}
      }
    ],
    "date": "2021-05-28",
    "categories": [],
    "contents": "\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2021-06-06T14:54:33-07:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-05-28-introduction-to-loops/",
    "title": "2. Introduction to Loops",
    "description": "Using loops in R.",
    "author": [
      {
        "name": "Shijing Zhou",
        "url": {}
      }
    ],
    "date": "2021-05-28",
    "categories": [],
    "contents": "\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2021-06-06T14:54:33-07:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-05-28-write-a-function/",
    "title": "3. Write a Function!",
    "description": "Demonstration of how to write a function with personality research data.",
    "author": [
      {
        "name": "Raleigh Goodwin, Vinita Vader",
        "url": {}
      }
    ],
    "date": "2021-05-28",
    "categories": [],
    "contents": "\r\nIntroduction\r\nIpsatization\r\nThis is a tutorial on using functional programming to solve specific problems in research. This tutorial addresses the issue of Ipsatization which consists of methods of data transformation used in Personality Psychology and Social Psychology research. Ipsatization transforms each participant’s ratings relative to their average response such that the total and the average of the participant’s scores across all items in the data set are zero (or another constant for all people) (Greer and Dunlap, 1997).\r\nPackages such as multicon have built functions like ipsatize() which enable standardizing rows of the dataframes being studied. However it does not address the various types of ipsative scorings available for carrying out different transformations.\r\nAn important aspect of using data transformations involves understanding the relationship between raw data and transformed data. The purpose of the function built here will be to address this specific issue.\r\nLoading Libraries\r\nBefore we get started, we need to load the libraries necessary to complete this tutorial. Loading the entire library may not be always necessary, especially if you intend to use it only once. This will be the case for rio, here, and knitr in this tutorial, so you may choose not to load them here if you’d like.\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(purrr)\r\nlibrary(rio) # optional\r\nlibrary(here) #optional\r\nlibrary(knitr) #optional\r\n\r\n\r\n\r\nAbout the Data\r\nFor this tutorial, we will be working with a dataset containing the Ten Item Personality Inventory (TIPI; Gosling, S. D., Rentfrow, P. J., & Swann, W. B., Jr., 2003), a brief measure of the Big Five Personality Domains (Goldberg, 1993). Each item asks respondents to rate themselves on attributes (e.g., extraverted, critical, anxious, calm, etc.) using a Likert scale ranging from 1 to 7, wherein:\r\n1 = Disagree strongly\r\n2 = Disagree moderately\r\n3 = Disagree a little\r\n4 = Neither agree nor disagree\r\n5 = Agree a little\r\n6 = Agree moderately\r\n7 = Agree strongly\r\nImporting the Data\r\nWhen importing data, two important things to keep in mind are your working directory and reproducibility. Where you save your files can impact the ease at which you can call them; you’ll have the best luck saving data files of interest within the corresponding R Project. rio’s import() function provides an easy method for importing data files, including the ability to set the class of the data to tibble, which helps to retain the data in a format which is more amenable to data manipulation in tidyverse. To enhance reproducibility across different devices, we’ll use the here() function within the here package when specifying our file path.\r\n\r\n\r\n# Import data\r\ndf_tipi <- rio::import(here::here(\"content/dataCT.csv\"), setclass = \"tibble\")\r\n\r\n\r\n\r\nFor the current project, we’ll only be working with the TIPI items, so to simplify the dataframe we’re using, we can select only those columns.\r\n\r\n\r\n# Select desired variables\r\ndata <- df_tipi %>% \r\n  select(TIPI1:TIPI10)\r\n\r\n\r\n\r\nNow we can take a look at the data we’ll be working with. The kable() function from the knitr package helps to format the data into a neat table.\r\n\r\n\r\n# Take a look at the data\r\ndata %>% \r\n  head(n = 5) %>% \r\n  knitr::kable()\r\n\r\n\r\nTIPI1\r\nTIPI2\r\nTIPI3\r\nTIPI4\r\nTIPI5\r\nTIPI6\r\nTIPI7\r\nTIPI8\r\nTIPI9\r\nTIPI10\r\n5\r\n3\r\n6\r\n2\r\n6\r\n6\r\n7\r\n2\r\n7\r\n1\r\n6\r\n7\r\n6\r\n7\r\n6\r\n3\r\n7\r\n5\r\n1\r\n1\r\n6\r\n6\r\n6\r\n1\r\n7\r\n5\r\n6\r\n5\r\n7\r\n7\r\n6\r\n7\r\n7\r\n5\r\n7\r\n6\r\n5\r\n1\r\n5\r\n1\r\n1\r\n3\r\n7\r\n2\r\n6\r\n4\r\n5\r\n5\r\n5\r\n3\r\n\r\nWith the libraries loaded and data imported, we can now begin building our function.\r\nBuilding Functions\r\nThere are several ways in which one could go about building functions. The approach outlined here should be viewed as one of the several approaches to go about building functions.\r\nAs you think about building a function, keep in mind the purpose of why you set to build a function in the first place. Your function will ideally solve a problem specific to your analysis or can also be used by others to carry out their analyses.\r\nLet’s state the problem first - The difference between raw and ipsatized data has been studied to some extent leading to several debates amongst researchers questioning the utility of these methods. It is therefore important to look at correlations between the raw and ipsatized data.\r\nNow that we understand the problem let’s think about how our function could address this problem. Here are a sequence of questions which will help you think about the function you intend to build.\r\nStep 1: What should my output look like?\r\nHere we are looking for an output which is a list consisting of raw and transformed or ipsatized data.\r\n\r\nipsatize.MeanDev(dataframe)\r\n\r\n>list\r\n $raw...\r\n $ipsatize...\r\n\r\nStep 2: What is the broad outline for obtaining this output?\r\nWe can build a function for ipsatizing the data and one for then putting the ipsatized data with the raw data within a larger list. Great we have a broad plan! Let’s break this down further.\r\nStep 3: How do we build the functions specified in step 2?\r\nWe will focus on one function at a time. We are going to first build the ipsatize function. Let’s break down the ipsatize function\r\ni. What is the \\(name\\) of the function?\r\nWe will call it ipsatize.MeanDev as the type of ipsatization this function will perform is Mean deviation.\r\nii. What will the the function $do$ ?\r\nIt will compute the means of the rows and subtract the mean from every score in the respective rows. In order to do this we will need an id column to calculate means for every row. This is slightly tricky but will be clear as we go along.\r\nA good way of thinking about writing functions is to start with the data. We will try and add an id column to the data.\r\nWe can use the row_number within mutate to create a new column.\r\n\r\n\r\ndata %>% \r\n  mutate(id = row_number()) %>%\r\n  head(n = 5) %>% \r\n  knitr::kable()\r\n\r\n\r\nTIPI1\r\nTIPI2\r\nTIPI3\r\nTIPI4\r\nTIPI5\r\nTIPI6\r\nTIPI7\r\nTIPI8\r\nTIPI9\r\nTIPI10\r\nid\r\n5\r\n3\r\n6\r\n2\r\n6\r\n6\r\n7\r\n2\r\n7\r\n1\r\n1\r\n6\r\n7\r\n6\r\n7\r\n6\r\n3\r\n7\r\n5\r\n1\r\n1\r\n2\r\n6\r\n6\r\n6\r\n1\r\n7\r\n5\r\n6\r\n5\r\n7\r\n7\r\n3\r\n6\r\n7\r\n7\r\n5\r\n7\r\n6\r\n5\r\n1\r\n5\r\n1\r\n4\r\n1\r\n3\r\n7\r\n2\r\n6\r\n4\r\n5\r\n5\r\n5\r\n3\r\n5\r\n\r\nThat works! Now let’s wrap this within a function. We will call it add_id\r\n\r\n\r\nadd_id <- function(df) {\r\n  df_id <- df %>% \r\n    mutate(id = row_number())\r\n  df_id\r\n}\r\n\r\n\r\n\r\nNow let’s check if it works.\r\n\r\n\r\nadd_id(data)%>% \r\n  head(n = 5) %>% \r\n  knitr::kable()\r\n\r\n\r\nTIPI1\r\nTIPI2\r\nTIPI3\r\nTIPI4\r\nTIPI5\r\nTIPI6\r\nTIPI7\r\nTIPI8\r\nTIPI9\r\nTIPI10\r\nid\r\n5\r\n3\r\n6\r\n2\r\n6\r\n6\r\n7\r\n2\r\n7\r\n1\r\n1\r\n6\r\n7\r\n6\r\n7\r\n6\r\n3\r\n7\r\n5\r\n1\r\n1\r\n2\r\n6\r\n6\r\n6\r\n1\r\n7\r\n5\r\n6\r\n5\r\n7\r\n7\r\n3\r\n6\r\n7\r\n7\r\n5\r\n7\r\n6\r\n5\r\n1\r\n5\r\n1\r\n4\r\n1\r\n3\r\n7\r\n2\r\n6\r\n4\r\n5\r\n5\r\n5\r\n3\r\n5\r\n\r\nPerfect! Now the next part is figuring out how to add a column with the mean rows. One way of thinking about this is we have a id variable which can be used to group the data. We can then use pivot_longer and pivot_wider to format the data.\r\n\r\n\r\ndata %>% \r\n  add_id() %>% \r\n  pivot_longer(cols = !id, names_to = \"col_names\")\r\n\r\n\r\n# A tibble: 24,950 x 3\r\n      id col_names value\r\n   <int> <chr>     <int>\r\n 1     1 TIPI1         5\r\n 2     1 TIPI2         3\r\n 3     1 TIPI3         6\r\n 4     1 TIPI4         2\r\n 5     1 TIPI5         6\r\n 6     1 TIPI6         6\r\n 7     1 TIPI7         7\r\n 8     1 TIPI8         2\r\n 9     1 TIPI9         7\r\n10     1 TIPI10        1\r\n# ... with 24,940 more rows\r\n\r\nWe have a 10 rows (equal to 10 variables) dedicated to every row id in this dataframe. We can use group_by to compute the means within every group and find deviations for every score from the mean.\r\n\r\n\r\ndata %>% \r\n  add_id() %>% \r\n  pivot_longer(cols = !id, names_to = \"col_names\") %>% \r\n  group_by(id) %>% \r\n  mutate(means_rowwise = mean(value, na.rm = T),\r\n         value = value - means_rowwise)\r\n\r\n\r\n# A tibble: 24,950 x 4\r\n# Groups:   id [2,495]\r\n      id col_names value means_rowwise\r\n   <int> <chr>     <dbl>         <dbl>\r\n 1     1 TIPI1       0.5           4.5\r\n 2     1 TIPI2      -1.5           4.5\r\n 3     1 TIPI3       1.5           4.5\r\n 4     1 TIPI4      -2.5           4.5\r\n 5     1 TIPI5       1.5           4.5\r\n 6     1 TIPI6       1.5           4.5\r\n 7     1 TIPI7       2.5           4.5\r\n 8     1 TIPI8      -2.5           4.5\r\n 9     1 TIPI9       2.5           4.5\r\n10     1 TIPI10     -3.5           4.5\r\n# ... with 24,940 more rows\r\n\r\nNow, we can use pivot_wider for reformatting the data to how it looked before.\r\n\r\n\r\ndata %>% \r\n  add_id() %>% \r\n  pivot_longer(cols = !id, names_to = \"col_names\") %>% \r\n  group_by(id) %>% \r\n  mutate(means_rowwise = mean(value, na.rm = T),\r\n         value = value - means_rowwise) %>% \r\n  pivot_wider(names_from = col_names, values_from = value) %>% \r\n  select(id, !means_rowwise) %>% \r\n   ungroup()\r\n\r\n\r\n# A tibble: 2,495 x 11\r\n      id  TIPI1  TIPI2  TIPI3 TIPI4  TIPI5  TIPI6  TIPI7  TIPI8 TIPI9\r\n   <int>  <dbl>  <dbl>  <dbl> <dbl>  <dbl>  <dbl>  <dbl>  <dbl> <dbl>\r\n 1     1  0.5   -1.5    1.5    -2.5  1.5    1.5    2.5   -2.5     2.5\r\n 2     2  1.1    2.1    1.1     2.1  1.1   -1.9    2.1    0.100  -3.9\r\n 3     3  0.400  0.400  0.400  -4.6  1.4   -0.600  0.400 -0.600   1.4\r\n 4     4  1      2      2       0    2      1      0     -4       0  \r\n 5     5 -3.1   -1.1    2.9    -2.1  1.9   -0.100  0.9    0.9     0.9\r\n 6     6 -0.200 -2.2    1.8    -2.2  1.8    0.8    1.8   -1.2     1.8\r\n 7     7 -1.9    1.1    0.100  -1.9  1.1    2.1   -1.9   -0.9     1.1\r\n 8     8 -0.200  0.8    1.8    -2.2  2.8   -0.200  0.8    0.8    -1.2\r\n 9     9 -0.300  0.7    1.7    -2.3 -0.300  0.7    1.7   -2.3     2.7\r\n10    10 -3.5    1.5   -1.5    -3.5  0.5    2.5    1.5    0.5     2.5\r\n# ... with 2,485 more rows, and 1 more variable: TIPI10 <dbl>\r\n\r\nNow we can wrap this into a function\r\n\r\n\r\nipsatize_MD <- function(df){\r\n  \r\n dfid <- df %>% \r\n   add_id()\r\n  \r\n output <- dfid %>% \r\n  pivot_longer(cols = !id, names_to = \"col_names\") %>% \r\n  group_by(id) %>% \r\n  mutate(means_rowwise = mean(value, na.rm = T),\r\n         value = value - means_rowwise) %>% \r\n  pivot_wider(names_from = col_names, values_from = value) %>% \r\n  select(id, !means_rowwise) %>% \r\n   ungroup()\r\n\r\n  output\r\n}\r\n\r\nipsatize_MD(data)\r\n\r\n\r\n# A tibble: 2,495 x 11\r\n      id  TIPI1  TIPI2  TIPI3 TIPI4  TIPI5  TIPI6  TIPI7  TIPI8 TIPI9\r\n   <int>  <dbl>  <dbl>  <dbl> <dbl>  <dbl>  <dbl>  <dbl>  <dbl> <dbl>\r\n 1     1  0.5   -1.5    1.5    -2.5  1.5    1.5    2.5   -2.5     2.5\r\n 2     2  1.1    2.1    1.1     2.1  1.1   -1.9    2.1    0.100  -3.9\r\n 3     3  0.400  0.400  0.400  -4.6  1.4   -0.600  0.400 -0.600   1.4\r\n 4     4  1      2      2       0    2      1      0     -4       0  \r\n 5     5 -3.1   -1.1    2.9    -2.1  1.9   -0.100  0.9    0.9     0.9\r\n 6     6 -0.200 -2.2    1.8    -2.2  1.8    0.8    1.8   -1.2     1.8\r\n 7     7 -1.9    1.1    0.100  -1.9  1.1    2.1   -1.9   -0.9     1.1\r\n 8     8 -0.200  0.8    1.8    -2.2  2.8   -0.200  0.8    0.8    -1.2\r\n 9     9 -0.300  0.7    1.7    -2.3 -0.300  0.7    1.7   -2.3     2.7\r\n10    10 -3.5    1.5   -1.5    -3.5  0.5    2.5    1.5    0.5     2.5\r\n# ... with 2,485 more rows, and 1 more variable: TIPI10 <dbl>\r\n\r\nThis works! We can add constraints to which type of variables can be added in the dataframe. For this we can build a function which only selects numeric columns.\r\n\r\n\r\njust_num <- function(df) {\r\n  if(sum(purrr::map_lgl(df, is.numeric)) == 0) {\r\n    stop(\"No numeric columns.\")\r\n  }\r\n    else{\r\n      df1 <- df[ , purrr::map_lgl(df, is.numeric)]\r\n      df1\r\n    }\r\n}\r\n\r\n\r\n\r\nIn the above function, we specify that if the sum of all possible numeric columns in a dataframe is 0, we stop the loop and throw an error message else return the dataframe. This will ensure that all the columns in the dataframe we are working with are numeric. We are using map_lgl from the purrr package which maps the is.numeric function to every column in the dataframe.\r\nLet’s give this function a try. We know that the dataframe “data” has all columns of class numeric whereas df_tipi does not.\r\n\r\n\r\nncol(just_num(df_tipi)) == (ncol(df_tipi))\r\n\r\n\r\n[1] FALSE\r\n\r\nncol(just_num(data)) == (ncol(data))\r\n\r\n\r\n[1] TRUE\r\n\r\nThis works!\r\nNow we can add this to the main function.\r\n\r\n\r\nipsatize_MD <- function(df){\r\n  \r\n df_clean <- df %>% \r\n   just_num() %>% \r\n   add_id()\r\n  \r\n output <- df_clean %>% \r\n  pivot_longer(cols = !id, names_to = \"col_names\") %>% \r\n  group_by(id) %>% \r\n  mutate(means_rowwise = mean(value, na.rm = T),\r\n         value = value - means_rowwise) %>% \r\n  pivot_wider(names_from = col_names, values_from = value) %>% \r\n  select(id, !means_rowwise) %>% \r\n   ungroup() %>% \r\n   select(-id)\r\n\r\n  output\r\n}\r\n\r\nipsatize_MD(data)\r\n\r\n\r\n# A tibble: 2,495 x 10\r\n    TIPI1  TIPI2  TIPI3 TIPI4  TIPI5  TIPI6  TIPI7  TIPI8 TIPI9 TIPI10\r\n    <dbl>  <dbl>  <dbl> <dbl>  <dbl>  <dbl>  <dbl>  <dbl> <dbl>  <dbl>\r\n 1  0.5   -1.5    1.5    -2.5  1.5    1.5    2.5   -2.5     2.5   -3.5\r\n 2  1.1    2.1    1.1     2.1  1.1   -1.9    2.1    0.100  -3.9   -3.9\r\n 3  0.400  0.400  0.400  -4.6  1.4   -0.600  0.400 -0.600   1.4    1.4\r\n 4  1      2      2       0    2      1      0     -4       0     -4  \r\n 5 -3.1   -1.1    2.9    -2.1  1.9   -0.100  0.9    0.9     0.9   -1.1\r\n 6 -0.200 -2.2    1.8    -2.2  1.8    0.8    1.8   -1.2     1.8   -2.2\r\n 7 -1.9    1.1    0.100  -1.9  1.1    2.1   -1.9   -0.9     1.1    1.1\r\n 8 -0.200  0.8    1.8    -2.2  2.8   -0.200  0.8    0.8    -1.2   -3.2\r\n 9 -0.300  0.7    1.7    -2.3 -0.300  0.7    1.7   -2.3     2.7   -2.3\r\n10 -3.5    1.5   -1.5    -3.5  0.5    2.5    1.5    0.5     2.5   -0.5\r\n# ... with 2,485 more rows\r\n\r\nA closer look will tell you that we could benefit from renaming the column names of the ips dataframe within the list. The paste function can be helpful to do this.\r\n\r\n\r\nrename_ips <- function(ipsatized_data){\r\n  names(ipsatized_data) <- paste0(names(ipsatized_data), \"_ips\")\r\n  return(ipsatized_data)\r\n}\r\n\r\nrename_ips(ipsatize_MD(data))\r\n\r\n\r\n# A tibble: 2,495 x 10\r\n   TIPI1_ips TIPI2_ips TIPI3_ips TIPI4_ips TIPI5_ips TIPI6_ips\r\n       <dbl>     <dbl>     <dbl>     <dbl>     <dbl>     <dbl>\r\n 1     0.5      -1.5       1.5        -2.5     1.5       1.5  \r\n 2     1.1       2.1       1.1         2.1     1.1      -1.9  \r\n 3     0.400     0.400     0.400      -4.6     1.4      -0.600\r\n 4     1         2         2           0       2         1    \r\n 5    -3.1      -1.1       2.9        -2.1     1.9      -0.100\r\n 6    -0.200    -2.2       1.8        -2.2     1.8       0.8  \r\n 7    -1.9       1.1       0.100      -1.9     1.1       2.1  \r\n 8    -0.200     0.8       1.8        -2.2     2.8      -0.200\r\n 9    -0.300     0.7       1.7        -2.3    -0.300     0.7  \r\n10    -3.5       1.5      -1.5        -3.5     0.5       2.5  \r\n# ... with 2,485 more rows, and 4 more variables: TIPI7_ips <dbl>,\r\n#   TIPI8_ips <dbl>, TIPI9_ips <dbl>, TIPI10_ips <dbl>\r\n\r\nAll we need to do now is wrap up the ipsatized data and raw data within a list.\r\n\r\n\r\nipsatize_MeanDev <- function(set){\r\n  \r\n  l <- list(\"ips\" = rename_ips(ipsatize_MD(data)) ,                \"raw\" = data,\r\n            \"correlation.matrix\" = cor(rename_ips(ipsatize_MD(data)), data))\r\n  l\r\n}\r\n\r\nips_raw_data <- ipsatize_MeanDev(data)\r\n\r\n\r\n\r\nSo now we have a list with the three dataframes. We can look at the correlations between raw and ipsatized data.\r\n\r\n\r\ntibble(\r\n  diag(ips_raw_data$correlation.matrix), colnames(ips_raw_data$ips), colnames(ips_raw_data$raw)\r\n)\r\n\r\n\r\n# A tibble: 10 x 3\r\n   `diag(ips_raw_data$corre~ `colnames(ips_raw_d~ `colnames(ips_raw_d~\r\n                       <dbl> <chr>                <chr>               \r\n 1                     0.960 TIPI1_ips            TIPI1               \r\n 2                     0.954 TIPI2_ips            TIPI2               \r\n 3                     0.949 TIPI3_ips            TIPI3               \r\n 4                     0.962 TIPI4_ips            TIPI4               \r\n 5                     0.919 TIPI5_ips            TIPI5               \r\n 6                     0.953 TIPI6_ips            TIPI6               \r\n 7                     0.949 TIPI7_ips            TIPI7               \r\n 8                     0.957 TIPI8_ips            TIPI8               \r\n 9                     0.958 TIPI9_ips            TIPI9               \r\n10                     0.941 TIPI10_ips           TIPI10              \r\n\r\nWe can also plot raw and ipsatized data. For example, lets look at the item 1.\r\n\r\n\r\nTIPI_item1 <- data.frame(ips_raw_data$raw$TIPI1, ips_raw_data$ips$TIPI1_ips)\r\n\r\nTIPI_item1 %>% \r\n  ggplot()+\r\n   geom_density(aes(x=TIPI_item1[,1]), colour=\"red\", fill = \"red\", alpha = .5) + \r\n   geom_density(aes(x=TIPI_item1[,2]), colour=\"blue\", fill = \"blue\", alpha = .5) +\r\n  theme_minimal()\r\n\r\n\r\n\r\n\r\nThings to work on\r\nFormatting - how to add links\r\nPlots - make them pretty, can add a vline for the mean, can change colors to a colorblind palette, can annotate\r\nconclusion\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-05-28-write-a-function/write-a-function_files/figure-html5/unnamed-chunk-19-1.png",
    "last_modified": "2021-06-06T18:22:41-07:00",
    "input_file": "write-a-function.knit.md"
  }
]
